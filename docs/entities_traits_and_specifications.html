<!-- HTML header for doxygen 1.8.3.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>OpenAssetIO [beta]: Entities, Traits and Specifications</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="styles.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="all-content">
<div id="body-content">
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">OpenAssetIO [beta]
   </div>
   <div id="projectbrief">An abstract API for generalising interactions between a host application and an asset management system</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('entities_traits_and_specifications.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Entities, Traits and Specifications </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The concepts discussed on this page are key to understanding how OpenAssetIO extends beyond the simple resolution of an <a class="el" href="glossary.html#entity_reference">Entity Reference</a> into a file path into first-class asset centric workflows.</p>
<h1><a class="anchor" id="Entities"></a>
Entities</h1>
<p>To recap, within OpenAssetIO, a <a class="el" href="glossary.html#host">host</a> communicates with an <a class="el" href="glossary.html#asset_management_system">Asset Management System</a> to query and manage the existence of <a class="el" href="glossary.html#entity">entities</a>. An entity is a logical thing managed within a pipeline or workflow by the asset manager. Within the Media and Entertainment sector, this could be a shot, an image sequence, a 3D model or a script.</p>
<p>At its core OpenAssetIO has no detailed understanding of the specifics of any given entity, only that:</p><ul>
<li>Conceptually they may or may not exist.</li>
<li>Entities conform to one or more <a class="el" href="glossary.html#trait">traits</a> that define what data is associated with the entity.</li>
<li>They may (or may not) have multiple versions.</li>
<li>They may (or may not) have relationships to other entities.</li>
</ul>
<p>An <a class="el" href="glossary.html#entity_reference">Entity Reference</a> is the token used to identify a specific entity within the system. These references are (generally) in the form of a <a href="https://en.wikipedia.org/wiki/Uniform_Resource_Identifier">URI</a>. The format of the reference itself is owned by the <a class="el" href="glossary.html#manager">manager</a> and conceptually, to the host, it is an opaque handle. Because of this (and the fact that it is specifically only an identifier), no concrete information about an entity can be determined from its reference alone.</p>
<p>OpenAssetIO's purpose is to define a standardized set of actions that can be performed to retrieve information about an entity from one of these opaque references, or to create new ones.</p>
<h1><a class="anchor" id="Traits"></a>
Traits</h1>
<p>Within the API, it is often neccesary to classify an entity, relationship or the nature of the calling environment to ensure data is handled correctly.</p>
<p>This is accomplished within OpenAssetIO using a set of 'traits'. A trait represents a concrete characteristic manifest by the thing in question. A trait may have one or more properties associated with it.</p>
<p>For entities, traits define the nature of that entity and what associated data it holds.</p>
<p>For example, an entity representing an image stored in an EXR file may have the <code>image</code>, <code>raster</code> and <code>locatableContent</code> traits. Each of these conveys a different characteristic of that entity:</p><ul>
<li><code>locatableContent</code>: Data is accessed elsewhere, through the path (or URL) supplied in the trait's <code>location</code> property.</li>
<li><code>image</code>: That the entity represents two-dimensional visual data. This trait has properties such <code>colorSpace</code>.</li>
<li><code>raster</code>: That the data is in the form of pixels.</li>
</ul>
<p>A procedural test chart image may combine <code>image</code>, <code>procedural</code> and <code>checkerBoard</code> traits, defining:</p><ul>
<li><code>image</code>: That the entity represents two-dimensional visual data.</li>
<li><code>procedural</code>: That it is a parameterized representation</li>
<li><code>checkerBoard</code>: A well-known set of properties that parameterize the generation of a checker board.</li>
</ul>
<p>A character model in a USD file could use the <code>locatableContent</code> and <code>geometry</code> traits, defining:</p><ul>
<li><code>locatableContent</code>: Data is accessed elsewhere.</li>
<li><code>geometry</code>: That the data contains meshes.</li>
</ul>
<p>Traits allow a consumer of data to request or consider only the specific qualities it understands. For example, when publishing a new entity, a <a class="el" href="glossary.html#manager">manager</a> may choose to adapt its high-level behaviour based on whether or not the entity has the <code>locatableContent</code> trait - to ensure data is moved to long-term storage.</p>
<p>The manager doesn't need to check an extensive list of which entity types may be registered with data on disk - it just checks if any given entity has that specific trait.</p>
<h1><a class="anchor" id="entity_data"></a>
Entity Data</h1>
<p>Every <a class="el" href="glossary.html#trait">Trait</a> associated with an <a class="el" href="glossary.html#entity">entity</a> can define zero or more key/value pairs of data (properties) that the entity (may) hold.</p>
<p>Traits are the mechanism by which a <a class="el" href="glossary.html#host">host</a> requests specific data about an entity at runtime. The <a class="el" href="classopenassetio_1_1v1_1_1host_api_1_1_manager.html#a3821fa69b2c22f8a5e057de0e191289e">resolve</a> method asks the manager to retrieve the data for a specific set of traits for one or more <a class="el" href="glossary.html#entity_reference">entity references</a>.</p>
<p>Continuing the example above, to determine the path to the character model, the host would resolve the data for the <code>locatableContent</code> trait, and read the <code>location</code> property to locate the data.</p>
<p>A tool that displays EXR image sequences may resolve the <code>locatableContent</code>, <code>image</code>, <code>frameRange</code>, and <code>playback</code> traits. The data provided by the manager then being used to control the colorspace and frame range/rate used for playback. This avoids fragile mechanisms such as extension-based mappings and brute-force filesystem searches.</p>
<p>The <a class="el" href="glossary.html#Context">Context</a> passed to the API methods by the host plays an important role during resolution. Its <a class="el" href="glossary.html#locale">locale</a> property also makes use of traits to specify details of the host environment. These may affect the resolved <em>value</em> of a trait property, but must never change the interpretation or format of that value.</p>
<dl class="section note"><dt>Note</dt><dd>In many real-world production systems, entities are manageed through distributed service-oriented platforms. The fact that a host must request the specific data for one or more concrete traits means that the manager does not have to worry about retrieving all possible data for any given entity. Host however, should be careful to only request traits they need at runtime, to avoid creating more work for the manager than is neccesary.</dd></dl>
<h2><a class="anchor" id="entities_not_just_for_files"></a>
Not Just for Files</h2>
<p>The above examples have focused on entities that happen to represent data held on disk in files, simply because this is a common patten in current pipelines, and serves as a gentle introduction to the topic.</p>
<p>There is no requirement for entities to map to file system data in OpenAsssetIO, that quality is just another 'trait' - the <code>locatableContent</code> trait.</p>
<p>Another valuable use of the API is to allow applications to work at the conceptual level of 'shots' and 'sequences' (or any other organizational structure that may be desired).</p>
<p>Consider an editorial application that wants to update a production tracking system based on changes to the suplied edit of a film. A host could use the <code>shot</code> and <code>frameRange</code> traits and their associated data fields to query and publish shot timing information directly to the management system.</p>
<p>The API contract states that a <a class="el" href="glossary.html#manager">manager</a> <b>must</b> guarantee to store and recall any traits and their properties registered by this mechanism. This allows a host to manage arbitrary data through the asset management system without any special handling by the manager itself.</p>
<dl class="section warning"><dt>Warning</dt><dd>In OpenAssetIO, trait properties are limited to simple constants using basic types such as string, float, int and bool. Time-varying data is beyond the scope of this API and should be managed through alternate means such as <a href="http://opentimeline.io" target="_blank">OpenTimelineIO</a> or similar.</dd></dl>
<h3><a class="anchor" id="trait_mapping"></a>
Mapping to Existing Data</h3>
<p>A manager almost certainly holds entities created by means other than OpenAssetIO (its own interface, other APIs, etc.). Where possible a manager should attempt to 'bridge' any internal data to and from the well-known OpenAssetIO traits and their properties so this data is available through the API to hosts and other consumers.</p>
<h2><a class="anchor" id="trait_property_modification"></a>
Modifying Trait Properties</h2>
<p>Aside from mapping trait properties to it's internal data model, a manager is also free to re-write any property values that it concretely understands - with the sole condition that the updated value must be logically the same as the one registered by the host.</p>
<p>The most common case of rewriting property data is with the <code>locatableContent</code> trait. In fact, the sole purpose of the API is to facilitate rewriting the <code>location</code> property of this trait!</p>
<p>The <code>location</code> property holds the path (or URL) to an entity's data. Depending on the process environment, this may need to be one of many different possible locations. A resolve on a render farm may need read from some local cache, where as a host writing a new version of an entity could be directed to a staging area. The manager should pick the most appropriate location based on the calling context's <a class="el" href="glossary.html#locale">locale</a>.</p>
<p>The point to note is that regardless of the value, the <code>location</code> is always pointing to the data for the specific referenced entity.</p>
<dl class="section warning"><dt>Warning</dt><dd>If a manager does <em>not</em> understand the semantic meaning of any given trait or its property values, it should ensure all registered values are returned verbatim for any trait set its management policy supports for write.</dd></dl>
<h2><a class="anchor" id="traits_as_views"></a>
Traits as Views</h2>
<p>At a programming level, traits are "views" on specification data. They provide concrete, strongly typed access to the open-ended data structures handled by the core API. In some languages, they extend to providing IDE-level or compile-time checks of their use.</p>
<h1><a class="anchor" id="Specifications"></a>
Specifications</h1>
<p>Specifications are a convenience used to define well-known sets of traits. They are used at runtime to ensure consistent handling of traits between different hosts and managers.</p>
<p>When a Specification combines triats into a <a class="el" href="glossary.html#trait_set">Trait Set</a> - they are additive. Each additional trait narrows the set's focus. Combining two traits does <em>not</em> mean "either/or".</p>
<p>A specifcation based on the earlier examples could be an <code>ImageSpecification</code> - composed of the <code>image</code>, <code>raster</code> and <code>locatableContent</code> traits. This specification defines an entity that must be a pixel-based image, with data held in a file.</p>
<p>There are three notable uses of specifications within OpenAssetIO:</p>
<ul>
<li>The context <a class="el" href="glossary.html#locale">locale</a> - to describe the specifics of the host environment calling the API.</li>
<li>During <a class="el" href="glossary.html#register">register</a> and <a class="el" href="glossary.html#resolve">resolve</a> - to hold the data for an <a class="el" href="glossary.html#entity">entity</a>.</li>
<li>Describing Relationships - to define some connection between one or more entities.</li>
</ul>
<h2><a class="anchor" id="locale_specifications"></a>
Locale Specifications</h2>
<p>Specifications only ever intended for use in the <a class="el" href="classopenassetio_1_1v1_1_1_context.html#ab46b43ae312ee13e8e17e4ee207bcbcf">Context.locale</a> (to describe which part of a host or application is calling the API) are known as "locale specifications".</p>
<p>The context locale is the mechanism by which a host can provide information to the manager so that it can supply the correct data in response to an API query, or adapt its behaviour during a publishing operation.</p>
<p>When used here, the specification's trait properties are used to convey not entity data, but information about the process environment. For example, the <code>usesUrls</code> trait defines that the host requires URLs instead of paths when addressing entity data not passed through the API.</p>
<h2><a class="anchor" id="entity_specifications"></a>
Entity Specifications</h2>
<p>Specifictions used with <a class="el" href="glossary.html#register">register</a> and returned by <a class="el" href="glossary.html#resolve">resolve</a> to hold <a class="el" href="glossary.html#entity">entity</a> data are known as "entity specifications". The <a class="el" href="glossary.html#trait_set">Trait Set</a> they define can also be used as a shorthand for consistency when:</p>
<ul>
<li>A host wishes to know if a manager would like to be involved in reads or writes of a specific kind of data.</li>
<li>A host wishes to define which data to resolve for an entity.</li>
<li>A host needs to present a browser or other UI element tailored to a specific kind of data.</li>
</ul>
<h2><a class="anchor" id="relationship_specifications"></a>
Relationship Specifications</h2>
<p>Specifications used in conjunction with the "related references" API methods, and cover the description of relationships not defined by the <em>type</em> of entities themselves. These are known as "relationship
specifications".</p>
<p>An example use case here would be an editorial application, that wishes to define a new shot in a production tracking system. Given the entity reference of an existing shot on the timeline, a specification that composed the <code>relationship</code> and <code>parent</code> traits would allow the host to query the correct parent to register the new shot to.</p>
<p>Using relationship traits ensures that this action can work with any asset management system, without needing first-class semantic understanding of the specific and most likely proprietary entity types and structure maintained by the manager.</p>
<p>Another example would be a specification composing the <code>relationship</code> and <code>dependency</code> traits to allow the runtime dependencies of a specific entity to be queried to facilitate data relocation.</p>
<h1><a class="anchor" id="specification_specificity"></a>
A Note on Trait Specificity and Entities</h1>
<h2><a class="anchor" id="Using"></a>
Trait Sets as a Filter Predicate</h2>
<p>When a <a class="el" href="glossary.html#trait_set">Trait Set</a> is used as a predicate to search for entities. Such as in <a class="el" href="classopenassetio_1_1host_api_1_1_manager_1_1_manager.html#a4d3241352a8c58e8cee15f376ac99a9a">getRelatedReferences</a>, or when browsing for assets, traits are considered additive, and they must all be satisifed.</p>
<p>As an example, consider a world-building tool wishing to browse for an arbitrary three-dimensional scene file to incorporate (e.g. USD). If it has no specific interest in exactly what type of objects it may contain - just that it is scene data - it should not include any traits that cover the specific types of scene items in the specification.</p>
<p>It may be tempting to form a specification composed of all potential traits, eg: <code>locatableContent</code>, <code>scene</code>, <code>camera</code>, <code>lights</code>, <code>geometry</code> etc. Because of the "additive" nature of a <a class="el" href="glossary.html#trait_set">trait sets</a>, this would effectively require that only scenes conforming to <em>all</em> of the listed traits should be presented. The correct trait collection to use would be just <code>locatableContent</code> and <code>scene</code> when browsing for an arbitrary scene file.</p>
<p>If it was required that the data be in a specific format (eg: USD) then the <code>format</code> property defined by the <code>sceneReader</code> trait should be set in the calling context's locale accordingly.</p>
<p>If a host <em>did</em> however require that a scene file contained a certain type of data - a camera for example, for a camera loader, then the <code>camera</code> trait should be added to indicate that only scenes containing a camera should be presented.</p>
<p>Another example would be when querying for an an EDL file in relation to a sequence entity. The traits used should only include a description of the nature of any of its content if this is specifically required for its use, so typically <code>locatableContent</code>, <code>timeline</code> is all that would be needed unless the host wished to specifically constrain the type of data referenced in the edit.</p>
<h2><a class="anchor" id="Publishing"></a>
Publishing</h2>
<p>When populating specifications with traits for publishing (see <a class="el" href="glossary.html#register">register</a>). The relevant traits are the ones that cover the data that is registered, so that that data is then available later on for <code>resolve</code> or when evaluating filter predicates.</p>
<h2><a class="anchor" id="Descriptions"></a>
Descriptions</h2>
<p>When a manager populates data in <a class="el" href="classopenassetio_1_1v1_1_1manager_api_1_1_manager_interface.html#a6235d6c679711ac561ecc50d2c7f1fa3">resolve</a>, then it should set all of the requested traits that are applicable to the entity, and only those that have data in the case of traits with properties. Traits that are not relevant, missing all data, or not known to the manager should be omitted.</p>
<p>When populating entityTraits, any traits that are applicable, or the manager is capable of providing data for should be set. The result of this query will be used by a host to decide if it is capable of consuming the entity's data in a specific way, so including all applicable traits is generally benefical.</p>
<dl class="section note"><dt>Note</dt><dd>This may need a little time to settle in paractice. There has been discussion around whether there is need to define 'excluded' traits, or how best to handle situations such as the 'USD camera cache' example, where there may also be caches with meshes <em>and</em> cameras. How does that intersection get handled? One option may be that the <code>camera</code> trait also included a <code>scenePath</code> property that allowed the rest of the scene to be filtered out. It probably means that registration should contain as much descriptive information as possible, where as filters/resolve should be as minimal as possible to avoid the logical conjunction of traits when being used as a predicate being too specific to match. So the case of a USD scene with meshes and cameras, then all relevant traits should be populated.</dd></dl>
<h1><a class="anchor" id="specification_mapping"></a>
Mapping to Native Types</h1>
<p>Where possible, both hosts and managers should attempt to map well-known trait sets to their native types. A manager with no UI of its own may not need to, but in most situations, a consistent mapping of traits to first-class concepts is essential for a well-formed user experience.</p>
<p>For example, the trait set of the <code>ImageSequenceSpecification</code> could be used by a compositor to know to read the data through its native image loading nodes. The trait properties could be mapped to controls on these nodes to determine what colorspace to apply to the image data and what frame range to use.</p>
<p>A manager may map the same traits to its own internal video format to ensure thumbnails and transcodes are generated for an entity, to be displayed in its browser as a preview.</p>
<h2><a class="anchor" id="specification_selection"></a>
Picking Which Traits to Use</h2>
<p>As a <a class="el" href="glossary.html#host">host</a>, it is important to use the correct specifications and traits when making calls to a <a class="el" href="glossary.html#manager">manager</a>. This ensures the expected type of entity is returned or registered. A manager must also accurately describe any entities when requested. In order to facilitate a common dialog between OpenAssetIO compatible systems, the project provides a set of well-known specifications and traits through industry-specific packages. Always use one of these where possible as they are, by definition, also known to other tools in the OpenAssetIO ecosystem.</p>
<p>Hosts and managers are also free to make their own specifications and traits for their native types. For example, creating a new specification by adding to the trait set of the <code>DocumentSpecification</code>, to represent a DCC tool's native file format. They should however, always use as many well-known traits as applicable. This ensures maximum compatibility with other tools.</p>
<dl class="section warning"><dt>Warning</dt><dd>Trait IDs are simply strings, and so exist in a global namespace so care should be taken when defining new or local traits to avoid the potential of collisions.</dd></dl>
<p>Any new tool, manager or vendor specific specifcations and traits should be listed in the appropriate technical documentation supplied with the software.</p>
<dl class="section note"><dt>Note</dt><dd>We are actively working on a library of well-known OpenAssetIO traits for the Media Creation sector. These are available in the <a href="https://github.com/TheFoundryVisionmongers/OpenAssetIO-MediaCreation" target="_blank">OpenAssetIO-MediaCreation</a> repository. </dd></dl>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.3.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
  </ul>
</div>
<hr class="footer"/>
<p id="copyright"><small>Copyright 2013-2023 The Foundry Visionmongers Ltd. OpenAssetIO is released under the <a href="https://www.apache.org/licenses/LICENSE-2.0.txt" target="_blank">Apache 2.0 License</a></small></p>
</div>
</body>
</html>
